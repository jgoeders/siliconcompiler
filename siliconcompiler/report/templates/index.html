 <!-- credit: https://codepen.io/danilonovakovic/pen/bxmWVM  -->
<!DOCTYPE html>
<html lang="en" >
<head>
  <meta charset="UTF-8">
  <title>CodePen - Directory Tree Viewer (Vanilla JS)</title>
  <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css'>
<link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/material-design-iconic-font/2.2.0/css/material-design-iconic-font.min.css'><link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">

</head>
<body>
<!-- partial:index.partial.html -->
<!--Import Google Icon Font-->
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
<div class="row">
  <div class="col s12 m4" id="treeView">
  </div>
</div>
<!-- partial -->
  <script>  
  /* shorthand functions (createElement is defined at bottom)*/
  const div = (props, ...children) => createElement("div", props, ...children);
  const ul = (props, ...children) => createElement("ul", props, ...children);
  const li = (props, ...children) => createElement("li", props, ...children);
  const i = (props, ...children) => createElement("i", props, ...children);
  const span = (props, ...children) => createElement("span", props, ...children);
  const header = (props, ...children) =>
    createElement("header", props, ...children);
  const p = (props, ...children) => createElement("p", props, ...children);
  const section = (props, ...children) =>
    createElement("section", props, ...children);
  const button = (props, ...children) =>
    createElement("button", props, ...children);
  
  /* File */
  
  const File = ({ name }) => {
    // Function to handle the click event on the file
    const handleClick = () => {
      // Replace this with the action you want to perform when the file is clicked
      // Send the file name to the Flask backend using fetch API
      fetch("/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ filename: name }),
      })
        .then(response => {
          if (!response.ok) {
            throw new Error("Network response was not ok");
          }
          // Parse the response JSON data
          return response.json();
        })
        .then(data => {
          // Access the JSON data returned from the Flask server
          console.log("Server response:", data);
        })
        .catch(error => {
          // Handle any errors that occurred during the fetch request
          console.error("Error sending request:", error);
        });
    };

    return div(
      { className: "file", onClick: handleClick }, // Add onClick event listener
      i({ className: "material-icons", style: "opacity: 0;" }, "arrow_right"),
      i({ className: "material-icons" }, "insert_drive_file"),
      span(null, name)
    );
  };
  
  /* Folder */
  
  const openedFolderIcon = "folder_open";
  const closedFolderIcon = "folder";
  const openedArrowIcon = "arrow_drop_down";
  const closedArrowIcon = "arrow_right";
  
  function changeOpened(event) {
    const folderHeader = event.target.classList.contains("folder-header")
      ? event.target
      : event.target.parentElement;
    const opened = folderHeader.getAttribute("opened") == "true";
    const newOpened = !opened;
  
    let icons = folderHeader.querySelectorAll(".material-icons");
    icons.forEach(icon => {
      if (/arrow/i.test(icon.textContent)) {
        icon.textContent = newOpened ? openedArrowIcon : closedArrowIcon;
      } else {
        icon.textContent = newOpened ? openedFolderIcon : closedFolderIcon;
      }
    });
  
    try {
      const sibling = folderHeader.nextElementSibling;
      if (newOpened) {
        sibling.classList.remove("hide");
      } else {
        sibling.classList.add("hide");
      }
    } catch (e) {
      console.warn(`No sibling of elem ${folderHeader} found ...`);
    }
  
    folderHeader.setAttribute("opened", newOpened);
  }
  
  const Folder = (props, ...children) => {
    const opened = props.opened || false;
    const arrowIcon = opened ? openedArrowIcon : closedArrowIcon;
    const folderIcon = opened ? openedFolderIcon : closedFolderIcon;
    const folderName = props.name || "unknown";
  
    return div(
      { className: "folder" },
      header(
        {
          onClick: changeOpened,
          className: "folder-header",
          opened: opened
        },
        i({ className: "material-icons" }, arrowIcon),
        i({ className: "material-icons" }, folderIcon),
        span(null, folderName)
      ),
      ul({ className: opened ? "" : "hide" }, ...children)
    );
  };

  /* TreeView */
  const TreeView = () => {
    return section({ className: "container" }, File({ name: "import.errors" }), File({ name: "import.log" }), File({ name: "import.warnings" }), Folder({ name: "inputs" }, File({ name: "gcd.pkg.json" })), Folder({ name: "outputs" }, File({ name: "gcd.pkg.json" }), File({ name: "gcd.v" })), File({ name: "replay.sh" }), Folder({ name: "reports" }, ), Folder({ name: "slpp_all" }, File({ name: "file.lst" }), File({ name: "file_elab.lst" }), File({ name: "file_map.lst" }), Folder({ name: "lib" }, Folder({ name: "work" }, File({ name: "gcd.v" }))), File({ name: "surelog.log" })));
  };
  
  const app = document.querySelector("#treeView");
  app.appendChild(createElement(TreeView));
  
  /* My react-clone mini library */
  
  function appendChildren(parent, children) {
    for (let child of children) {
      if (!child) continue;
      switch (typeof child) {
        case "string":
          const el = document.createTextNode(child);
          parent.appendChild(el);
          break;
        default:
          parent.appendChild(child);
          break;
      }
    }
  }
  function setStyle(el, style) {
    if (typeof style == "string") {
      el.setAttribute("style", style);
    } else {
      Object.assign(el.style, style);
    }
  }
  function setClass(el, className) {
    className.split(/\s/).forEach(element => {
      if (element) {
        el.classList.add(element);
      }
    });
  }
  function setProps(el, props) {
    const eventRegex = /^on([a-z]+)$/i;
    for (let propName in props) {
      if (!propName) continue;
  
      if (propName === "style") {
        setStyle(el, props[propName]);
      } else if (propName === "className") {
        setClass(el, props[propName]);
      } else if (eventRegex.test(propName)) {
        const eventToListen = propName.replace(eventRegex, "$1").toLowerCase();
        el.addEventListener(eventToListen, props[propName]);
      } else {
        el.setAttribute(propName, props[propName]);
      }
    }
  }
  
  //type, [props], [...children] 
  function createElement(type, props, ...children) {
    if (typeof type === "function") {
      return type(props);
    } else {
      const el = document.createElement(type);
      if (props && typeof props === "object") {
        setProps(el, props);
      }
      if (children) {
        appendChildren(el, children);
      }
      return el;
    }
  }
  </script>

</body>
</html>
